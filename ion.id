use hash;
use io;
use json;
use SemanticVersion from semver;
use WebClient from webclient;
use ziplib;

VERSION = 'v0.1.0';
REPO = 'http://iodinelang.github.io/Ion-Default-Repo';
LOCATION = './.deps';

class IonFileManager {
    func IonFileManager(self) {

    }

    func getDependencyLocation(self) {
        with (f = open('./ionfile.json', 'r')) {
            ionFile = json.parse(f.readAllText());
            if (!ionFile.contains('dependencyLocation')) {
                return null;
            }

            return ionFile['dependencyLocation'];
        }
    }

    func create(self) {
        with (f = open('./ionfile.json', 'w')) {
            f.write(json.dump({
                'sources': ['src'],
                'dependencies': {},
                'dependencyLocation': 'src'
            }));
        }
    }

    func addDep(self, pkg, fullVersion) {
        with (f = open('./ionfile.json', 'r')) {
            ionFile = json.parse(f.readAllText());
        }
        ver = SemanticVersion(fullVersion);
        ionFile['dependencies'][pkg] = '^{}.{}.{}'.format(ver.versionMajor,
            ver.versionMinor, ver.versionPatch);
        with (f = open('./ionfile.json', 'w')) {
            f.write(json.dump(ionFile));
        }
    }
}

class DataManager {
    func DataManager(self, *args) {
        self.location = LOCATION;
        if (args.getSize() == 1) {
            self.location = args[0];
        }
    }

    func getAll(self) {
        dataDir = '{}/data'.format(self.location);
        items = {};
        foreach (dataFile in io.Directory.getFiles(dataDir)) {
            _data = json.parse(open(dataFile, 'r').readAllText());
            items[_data['name']] = _data;
        }

        return items;
    }
}

class Uninstaller {
    func Uninstaller(self, package) {
        self.package = package;
        self.location = LOCATION;
    }

    func uninstall(self) {
        # TODO: Add force=true option
        dataDir = '{}/data'.format(self.location);
        foreach (dataFile in io.Directory.getFiles(dataDir)) {
            _data = json.parse(open(dataFile, 'r').readAllText());
            if (_data['dependencies'].contains(self.package)) {
                raise PackageRequiredException(self.package, _data['name']);
            }
        }

        pkgDataLoc = '{}/{}.json'.format(dataDir, self.package);
        packageDataFile = open(pkgDataLoc, 'r');
        _data = json.parse(packageDataFile.readAllText());
        foreach (file in _data['files']) {
            _file = '{}/{}'.format(self.location, file);
            io.File.remove(_file);
        }

        io.File.remove(pkgDataLoc);
    }
}

class Installer {
    func Installer(self, package, *args) {
        self.location = LOCATION;
        self.package = package;
        self.dependencyResolver = DependencyResolver(package);
        if (len (args) > 0) {
            self.location = args[0];
        } else {
            _loc = IonFileManager().getDependencyLocation();
            if (_loc != null) {
                self.location = '{}/.deps'.format(_loc);
            }
        }
    }

    func install(self, *args) {
        version = '*';
        if (len (args) == 1) {
            version = args[0];
        }

        toInstall = self.dependencyResolver.resolve(version);

        # This will contain all package info (for use when unpacking)
        data = {};
        # Chosen versions are stored here (so installations don't half-occur)
        chosenVersion = {};

        foreach (pkg in toInstall) {
            data[pkg] = self.fetch(pkg);
            foreach (version in data[pkg]['versions']) {
                _sv = SemanticVersion(version);
                reject = false;
                foreach (reqVersion in toInstall[pkg]) {
                    if (!_sv.isMatch(reqVersion)) {
                        reject = true;
                        break;
                    }
                }

                if (!reject) {
                    chosenVersion[pkg] = version;
                    break;
                }
            }

            if (!chosenVersion.contains(pkg)) {
                raise PackageMismatchException(pkg);
            }
        }

        # Actually install the packages
        self._installToDisk(data, chosenVersion);
        return chosenVersion;
    }

    func _installToDisk(self, data, chosenVersion) {
        if (!io.Directory.exists(self.location)) {
            io.Directory.create(self.location);
        }

        cacheDir = '{}/cache'.format(self.location);
        if (!io.Directory.exists(cacheDir)) {
            io.Directory.create(cacheDir);
        }

        dataDir = '{}/data'.format(self.location);
        if (!io.Directory.exists(dataDir)) {
            io.Directory.create(dataDir);
        }

        foreach (pkg in chosenVersion) {
            version = chosenVersion[pkg];
            pkgVerData = data[pkg]['versions'][version];
            src = pkgVerData['download'];
            zipLoc = '{}/{}-{}.zip'.format(cacheDir, pkg, version);
            WebClient().downloadFile(src, zipLoc);

            # SHA1 verification
            if (pkgVerData.contains('sha1')) {
                f = open(zipLoc, 'r');
                if (hash.sha1(f) != pkgVerData['sha1']) {
                    raise UnsafePackageException(pkg);
                }
            }


            ziplib.unzipToDirectory(zipLoc, cacheDir);
            zipDest = '{}/{}'.format(cacheDir, pkgVerData['ionfileLocation']);
            ionLoc = '{}/ionfile.json'.format(zipDest);
            ionData = json.parse(open(ionLoc, 'r').readAllText());
            sources = ionData['sources'];
            foreach (source in sources) {
                _loc = '{}/{}'.format(zipDest, source);
                _files = [];
                foreach (dir in io.Directory.getDirectories(_loc)) {
                    foreach (file in io.Directory.getFiles(dir)) {
                        _files.add(file.replace(_loc, '').substr(1));
                    }
                }

                foreach (file in io.Directory.getFiles(_loc)) {
                    _files.add(file.replace(_loc, '').substr(1));
                }

                io.Directory.copy(_loc, self.location, true);

                _dmp = json.dump({
                    'dependencies': data[pkg]['dependencies'],
                    'files': _files,
                    'version': version,
                    'name': pkg
                });

                open('{}/{}.json'.format(dataDir, pkg), 'w').write(Str(_dmp));
            }
            self._rmrf(zipDest);
        }

        self._rmrf(cacheDir);
    }

    func _rmrf(self, loc) {
        foreach (file in io.Directory.getFiles(loc)) {
            io.File.remove(file);
        }

        foreach (dir in io.Directory.getDirectories(loc)) {
            self._rmrf(dir);
        }
        io.Directory.remove(loc);
    }


    func fetch(self, pkg) {
        loc = '{}/{}.json'.format(REPO, pkg);
        print('GET ' + loc);
        return json.parse(WebClient().downloadString(loc));
    }
}

class DependencyResolver {
    func DependencyResolver(self, package) {
        self.package = package;
    }

    func fetch(self) {
        loc = '{}/{}.json'.format(REPO, self.package);
        print('GET ' + loc);
        return json.parse(WebClient().downloadString(loc));
    }

    func resolve(self, *args) {
        # resolve collects a list of dependencies to fetch with version
        # constraints.
        versions = ['*'];
        if (len (args) > 0) {
            # args appears to be a tuple.
            versions = [];
            foreach (arg in args) {
                versions.add(arg);
            }
        }
        # All dependencies are collected in toInstall
        toInstall = {};

        pkg = self.fetch();

        dependencies = pkg['dependencies'];

        # Key is package name, value is version
        foreach (dep in dependencies) {
            _deps = DependencyResolver(dep).resolve(dependencies[dep]);
            toInstall = self._join(toInstall, _deps);
        }

        toInstall = self._join(toInstall, {self.package: versions});
        return toInstall;
    }

    func _join(self, base, toJoin) {
        # Joins two dependency chains. Gives up if versions conflict.
        foreach (dep in toJoin) {
            if (!base.contains(dep)) {
                # Create a 1-list of version constraints.
                base[dep] = toJoin[dep];
            } else {
                foreach (_newDep in toJoin[dep]) {
                    base[dep].add(_newDep);
                }
            }
        }

        return base;
    }
}

class PackageMismatchException : Exception {
    func PackageMismatchException(self, package) {
        super('Could not continue - cannot install {}!'.format(package));
    }
}

class PackageRequiredException : Exception {
    func PackageRequiredException(self, package, dependedBy) {
        super('Could not continue - cannot uninstall {} (required by {})!'
            .format(package, dependedBy));
    }
}

class UnsafePackageException : Exception {
    func UnsafePackageException(self, package) {
        super(('The hash of {} could not be verified. Please delete ' +
            './.deps/cache immediately').format(package));
    }
}
